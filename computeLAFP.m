function [ mixtureDensity, alleleLocationMap, LAFPhasings, possibleLAF, probabilities ] = computeLAFP( possibleAlleles, mu, distanceAlleleMap, allAlleleDistanceMatrix )
%COMPUTELAFP Generates the P(LAF | Ci, mu) proability density function

    %attach the normal clone to the possible alleles to get a full Ci
    normalClone = {'AB'};
    normalCloneRepeated = normalClone(ones(size(possibleAlleles,2),1),:)';
    fullCombinations = [normalCloneRepeated; possibleAlleles];

    %compute the event distances from AB to the possible alleles
    transposedPhasings = fullCombinations';
    distanceMatrices = arrayfun(@(x)getEventDistanceFromMatrix(transposedPhasings(x,:),distanceAlleleMap, allAlleleDistanceMatrix), 1:size(transposedPhasings,1), 'UniformOutput', 0);

    %The only possible relationship between the subclones within a sample
    %is from AB to the possible alleles in our model. This is represented with the phylogeny 
    phylogeny = [0 1; 0 0]; 
    validDistanceMatrices = cellfun(@(matrix) matrix .* (phylogeny~= 0), distanceMatrices, 'UniformOutput', 0);

    %If mu is 0 for either the tumor subclone or the normal component, it
    %has no alleles so we do not allow this set of possible alleles
    zeroMu = mu == 0;
    for i = 1:length(validDistanceMatrices)
        validDistanceMatrices{i}(isnan(validDistanceMatrices{i})) = 0; %also remove nan indices, here phylogeny is 0
        validDistanceMatrices{i}(:,zeroMu) = [];
    end
    
    %if mu is 0, we set the total sum to 1 as only one component is present
    %and thus the LAF are generated by one component. Otherwise we sum the
    %event distances which we will use later for normalization of the
    %probabilities of observing each LAF. 
    bestScores = cellfun(@(matrix) max(matrix), validDistanceMatrices, 'UniformOutput', 0);
    if(max(cell2mat(bestScores)) < 1)
        scoreSums = cellfun(@(x) 1, validDistanceMatrices, 'UniformOutput', 0);
    else
        scoreSums = cellfun(@(x) sum(x(:)), validDistanceMatrices, 'UniformOutput', 0);
    end
    
    % compute the LAF for each combination
    AMatches = strfind(fullCombinations, 'A');
    BMatches = strfind(fullCombinations, 'B');
    
    ALengths = cellfun(@length, AMatches);
    BLengths = cellfun(@length, BMatches);
    
    ACounts = bsxfun(@times, ALengths, mu');
    BCounts = bsxfun(@times, BLengths, mu');
    
    LAF = min(sum(ACounts,1), sum(BCounts,1)) ./ (sum(ACounts,1) + sum(BCounts,1));
   
    %remove the LAF with a score of Inf, these are not possible based on
    %the event distance
    infEntries = isinf(cell2mat(scoreSums));
    LAF(infEntries) = [];
    scoreSums(infEntries) = [];
    allAlleles = fullCombinations;
    allAlleles(1,:) = [];
    allAlleles(infEntries) = [];
    allScores = cellfun(@(x) 1 ./ x, scoreSums, 'UniformOutput', 0);
    
    %Obtain the possible LAF and compute their probabilities by normalizing
    %the event distances
    possibleLAF = unique(LAF);
    LAFInd = arrayfun(@(x)find(LAF == x), possibleLAF, 'UniformOutput', 0);
    lafScores = arrayfun(@(x)sum(cell2mat(allScores(cell2mat(x)))), LAFInd);
    LAFPhasings = arrayfun(@(x) allAlleles(cell2mat(x)), LAFInd, 'UniformOutput', 0);
    totalScore = sum(cell2mat(allScores));
    probabilities = lafScores / totalScore;
    
    noiseStandardDeviation = 0.0224; %This is estimated from the normal reference samples, hardcoded for now. 
    %use these probabilities to make the P(LAF | Ci, mu) distribution
    %also obtain the locations of the valleys that separate the x from
    %where we assign different alleles to a copy number. 
    [mixtureDensity, valleyLocs] = generateGaussianMixtureModel(possibleLAF,noiseStandardDeviation, probabilities); %hardcoded sigma

    %assign the alleles to the valley locations
    finalLocs = [1, valleyLocs', length(mixtureDensity(:,1))];
    alleleLocationMap = [];
    for i = 1:length(finalLocs)-1
       alleleLocationMap = [alleleLocationMap; [finalLocs(i), finalLocs(i+1)]];
    end
    
end

